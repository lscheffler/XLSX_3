*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="faststrings.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS faststrings AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: about		&& Class Information
		*m: addstringtoheap		&& Adds the string to the heap for parsing
		*m: at		&& Fast string replacement for AT() function
		*m: atc		&& Fast string replacement for ATC() function
		*m: getfirstsegment		&& Gets the first segment bounded by delimiters
		*m: getnextsegment		&& Gets the next segment bounded by delimiters
		*m: getxmlfirstsegment		&& Gets the first segment in a XML structure
		*m: getxmlnextsegment		&& Gets the next segment in a XML structure
		*m: getxmlsegment		&& Gets the xml segment
		*m: oninit		&& User defined Init()
		*m: releasestringfromheap		&& Releases the fast string from the heap
		*m: rstring		&& Returns the right part of the string from the starting point
		*m: strextract		&& Fast string replacement for STREXTRACT() function
		*m: substr		&& Fast String replacement for SUBSTR() function
		*p: loaddlls		&& Indicates whether to execute the DECLARE - DLLs commands for the Win32 API ***Boolean
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED Init
	AutoSize = .T.
	Caption = "clsFastStrings"
	Height = 17
	loaddlls = .T.		&& Indicates whether to execute the DECLARE - DLLs commands for the Win32 API ***Boolean
	Name = "faststrings"
	Visible = .F.
	Width = 81
	_memberdata = <VFPData>
		<memberdata name="loaddlls" type="property" display="LoadDLLs"/>
		<memberdata name="at" type="method" display="AT"/>
		<memberdata name="atc" type="method" display="ATC"/>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="addstringtoheap" type="method" display="AddStringToHeap"/>
		<memberdata name="getfirstsegment" type="method" display="GetFirstSegment"/>
		<memberdata name="getnextsegment" type="method" display="GetNextSegment"/>
		<memberdata name="getxmlfirstsegment" type="method" display="GetXMLFirstSegment"/>
		<memberdata name="getxmlnextsegment" type="method" display="GetXMLNextSegment"/>
		<memberdata name="getxmlsegment" type="method" display="GetXMLSegment"/>
		<memberdata name="oninit" type="method" display="OnInit"/>
		<memberdata name="rstring" type="method" display="RString"/>
		<memberdata name="releasestringfromheap" type="method" display="ReleaseStringFromHeap"/>
		<memberdata name="strextract" type="method" display="StrExtract"/>
		<memberdata name="substr" type="method" display="SubStr"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROTECTED PROCEDURE about		&& Class Information
		*-*
		*-* Idea for class by Rick Hodgin on Universal Thread (Thread Id 01674989)
		*-* Class Written by Gregory Green
		*-* Based on suggestion by Christof Wollenhaupt
		*-*
		*-*  Note:  SET EXACT must be set to off
		*-*
		*-* Change History
		*-*
	ENDPROC

	PROCEDURE addstringtoheap		&& Adds the string to the heap for parsing
		LPARAMETERS tcString
		LOCAL loString
		loString = CREATEOBJECT("Empty")
		ADDPROPERTY(loString, "BaseAdr", 0)
		ADDPROPERTY(loString, "LastAdr", 0)
		ADDPROPERTY(loString, "Length", LEN(tcString))
		ADDPROPERTY(loString, "XMLDelimiter", "")
		ADDPROPERTY(loString, "BegDelimiter", "")
		ADDPROPERTY(loString, "EndDelimiter", "")
		loString.BaseAdr = apiHeapAlloc(apiGetProcessHeap(), 0, loString.Length)
		SYS(2600, loString.BaseAdr, loString.Length, tcString)
		RETURN loString
	ENDPROC

	PROCEDURE at		&& Fast string replacement for AT() function
		LPARAMETERS tcFindText, toString, tnOccurrence
		LOCAL lnBeg, lcVal, lnEnd, lnLen
		IF PCOUNT() = 2
			tnOccurrence = 1
		ENDIF
		lnLen = LEN(tcFindText)
		lnOccurrence = 0
		lnBeg = 1
		DO WHILE lnBeg < toString.Length
			lcVal = SYS(2600, toString.BaseAdr-1 + lnBeg, lnLen)
			IF lcVal == tcFindText
				lnOccurrence = lnOccurrence + 1
				IF lnOccurrence = tnOccurrence
					RETURN lnBeg
				ENDIF
			ENDIF
			lnBeg = lnBeg + 1
		ENDDO
		RETURN 0
	ENDPROC

	PROCEDURE atc		&& Fast string replacement for ATC() function
		LPARAMETERS tcFindText, toString, tnOccurrence
		LOCAL lnBeg, lcVal, lnEnd, lnLen
		IF PCOUNT() = 2
			tnOccurrence = 1
		ENDIF
		tcFindText = UPPER(tcFindText)
		lnLen = LEN(tcFindText)
		lnOccurrence = 0
		lnBeg = 1
		DO WHILE (lnBeg + lnLen - 1) <= toString.Length
			lcVal = UPPER(SYS(2600, toString.BaseAdr-1 + lnBeg, lnLen))
			IF lcVal == tcFindText
				lnOccurrence = lnOccurrence + 1
				IF lnOccurrence = tnOccurrence
					RETURN lnBeg
				ENDIF
			ENDIF
			lnBeg = lnBeg + 1
		ENDDO
		RETURN 0
	ENDPROC

	PROCEDURE getfirstsegment		&& Gets the first segment bounded by delimiters
		LPARAMETERS toString, tcBegDelimiter, tcEndDelimiter
		LOCAL lnBeg, lcVal, lnEnd, lnBegLen, lnEndLen
		toString.BegDelimiter = tcBegDelimiter
		toString.EndDelimiter = tcEndDelimiter
		lnBegLen = LEN(toString.BegDelimiter)
		lnEndLen = LEN(toString.EndDelimiter)
		lnBeg = 1
		DO WHILE lnBeg <= toString.Length
			lcVal = SYS(2600, toString.BaseAdr-1 + lnBeg, lnBegLen)
			IF lcVal == toString.BegDelimiter
				FOR lnEnd=lnBeg+lnBegLen TO toString.Length
					lcVal = SYS(2600, toString.BaseAdr-1 + lnEnd, lnEndLen)
					IF lcVal == toString.EndDelimiter
						toString.LastAdr = lnEnd + lnEndLen
						RETURN SYS(2600, toString.BaseAdr-1 + lnBeg, lnEnd - lnBeg + lnEndLen + 1)
					ENDIF
				ENDFOR
				lnBeg = toString.Length
			ENDIF
			lnBeg = lnBeg + 1
		ENDDO
		toString.LastAdr = toString.Length
		RETURN ""
	ENDPROC

	PROCEDURE getnextsegment		&& Gets the next segment bounded by delimiters
		LPARAMETERS toString
		LOCAL lnBeg, lcVal, lnEnd, lnBegLen, lnEndLen
		lnBegLen = LEN(toString.BegDelimiter)
		lnEndLen = LEN(toString.EndDelimiter)
		lnBeg = toString.LastAdr
		DO WHILE lnBeg <= toString.Length
			lcVal = SYS(2600, toString.BaseAdr-1 + lnBeg, lnBegLen)
			IF lcVal == toString.BegDelimiter
				FOR lnEnd=lnBeg+lnBegLen TO toString.Length
					lcVal = SYS(2600, toString.BaseAdr-1 + lnEnd, lnEndLen)
					IF lcVal == toString.EndDelimiter
						toString.LastAdr = lnEnd + lnEndLen
						RETURN SYS(2600, toString.BaseAdr-1 + lnBeg, lnEnd - lnBeg + lnEndLen + 1)
					ENDIF
				ENDFOR
				lnBeg = toString.Length
			ENDIF
			lnBeg = lnBeg + 1
		ENDDO
		toString.LastAdr = toString.Length
		RETURN ""
	ENDPROC

	PROCEDURE getxmlfirstsegment		&& Gets the first segment in a XML structure
		LPARAMETERS toString, tcBegDelimiter
		LOCAL lnBeg, lcVal, lnEnd, lnBegLen, lnEndLen, lcAltDelimiter, lcEndDelimiter, llShort, lcBegDelimiter
		toString.XMLDelimiter = ALLTRIM(tcBegDelimiter, 1, "<", ">", " ")
		lcAltDelimiter = '<' + toString.XMLDelimiter + " "
		lcBegDelimiter = '<' + toString.XMLDelimiter + '>'
		lnBegLen = LEN(lcBegDelimiter)
		lnBeg    = 1
		DO WHILE (lnBeg + lnBegLen - 1) <= toString.Length
			lcVal = SYS(2600, toString.BaseAdr-1 + lnBeg, lnBegLen)
			IF lcVal == lcBegDelimiter .OR. lcVal == lcAltDelimiter
				DO CASE
					CASE lcVal == lcBegDelimiter
						lcEndDelimiter = STUFF(lcBegDelimiter, 2, 0, "/")
						llShort = .F.
		
					CASE lcVal == lcAltDelimiter
						lcEndDelimiter = "/>"
						llShort = .T.
				ENDCASE
				lnEndLen = LEN(lcEndDelimiter)
				lnEnd = lnBeg + lnBegLen
				DO WHILE (lnEnd + lnEndLen - 1) <= toString.Length
					lcVal = SYS(2600, toString.BaseAdr-1 + lnEnd, lnEndLen)
					DO CASE
						CASE lcVal = "<" .AND. !(lcVal == lcEndDelimiter)
							DO WHILE lcVal != ">" .AND. lnEnd < toString.Length
								lnEnd = lnEnd + 1
								lcVal = SYS(2600, toString.BaseAdr-1 + lnEnd, 1)
							ENDDO
		
						CASE llShort .AND. lcVal = ">"
							lcEndDelimiter = STUFF(lcBegDelimiter, 2, 0, "/")
							lnEndLen = LEN(lcEndDelimiter)
							llShort  = .F.
		
						CASE lcVal == lcEndDelimiter
							toString.LastAdr = lnEnd + lnEndLen
							RETURN SYS(2600, toString.BaseAdr-1 + lnBeg, lnEnd - lnBeg + lnEndLen)
					ENDCASE
					lnEnd = lnEnd + 1
				ENDDO
				lnBeg = toString.Length
			ENDIF
			lnBeg = lnBeg + 1
		ENDDO
		toString.LastAdr = toString.Length
		RETURN ""
	ENDPROC

	PROCEDURE getxmlnextsegment		&& Gets the next segment in a XML structure
		LPARAMETERS toString
		LOCAL lnBeg, lcVal, lnEnd, lnBegLen, lnEndLen, lcAltDelimiter, lcEndDelimiter, llShort, lcBegDelimiter
		lcAltDelimiter = '<' + toString.XMLDelimiter + " "
		lcBegDelimiter = '<' + toString.XMLDelimiter + '>'
		lnBegLen = LEN(lcBegDelimiter)
		lnBeg    = toString.LastAdr
		DO WHILE (lnBeg + lnBegLen - 1) <= toString.Length
			lcVal = SYS(2600, toString.BaseAdr-1 + lnBeg, lnBegLen)
			IF lcVal == lcBegDelimiter .OR. lcVal == lcAltDelimiter
				DO CASE
					CASE lcVal == lcBegDelimiter
						lcEndDelimiter = STUFF(lcBegDelimiter, 2, 0, "/")
						llShort = .F.
		
					CASE lcVal == lcAltDelimiter
						lcEndDelimiter = "/>"
						llShort = .T.
				ENDCASE
				lnEndLen = LEN(lcEndDelimiter)
				lnEnd = lnBeg + lnBegLen
				DO WHILE (lnEnd + lnEndLen - 1) <= toString.Length
					lcVal = SYS(2600, toString.BaseAdr-1 + lnEnd, lnEndLen)
					DO CASE
						CASE lcVal = "<" .AND. !(lcVal == lcEndDelimiter)
							DO WHILE lcVal != ">" .AND. lnEnd < toString.Length
								lnEnd = lnEnd + 1
								lcVal = SYS(2600, toString.BaseAdr-1 + lnEnd, 1)
							ENDDO
		
						CASE llShort .AND. lcVal = ">"
							lcEndDelimiter = STUFF(lcBegDelimiter, 2, 0, "/")
							lnEndLen = LEN(lcEndDelimiter)
							llShort  = .F.
		
						CASE lcVal == lcEndDelimiter
							toString.LastAdr = lnEnd + lnEndLen
							RETURN SYS(2600, toString.BaseAdr-1 + lnBeg, lnEnd - lnBeg + lnEndLen)
					ENDCASE
					lnEnd = lnEnd + 1
				ENDDO
				lnBeg = toString.Length
			ENDIF
			lnBeg = lnBeg + 1
		ENDDO
		toString.LastAdr = toString.Length
		RETURN ""
	ENDPROC

	PROCEDURE getxmlsegment		&& Gets the xml segment
		LPARAMETERS txString, tcBegDelimiter
		LOCAL lnBeg, lcVal, lnEnd, lnBegLen, lnEndLen, lcAltDelimiter, lcEndDelimiter, lcRtnSegment, loString
		LOCAL llReleaseHeap, lcBegDelimiter
		lcRtnSegment   = ""
		tcBegDelimiter = ALLTRIM(tcBegDelimiter, 1, "<", ">", " ")
		lcAltDelimiter = '<' + tcBegDelimiter + " "
		lcBegDelimiter = '<' + tcBegDelimiter + '>'
		lnBegLen = LEN(lcBegDelimiter)
		DO CASE
			CASE VARTYPE(txString) = 'C'
				llReleaseHeap = .T.
				loString = this.AddStringToHeap(txString)
		
			CASE VARTYPE(txString) = 'O'
				llReleaseHeap = .F.
				loString = txString
		
			OTHERWISE
				RETURN ""
		ENDCASE
		lnBeg = 1
		DO WHILE (lnBeg + lnBegLen - 1) <= loString.Length
			lcVal = SYS(2600, loString.BaseAdr-1 + lnBeg, lnBegLen)
			IF lcVal == lcBegDelimiter .OR. lcVal == lcAltDelimiter
				DO CASE
					CASE lcVal == lcBegDelimiter
						lcEndDelimiter = STUFF(lcBegDelimiter, 2, 0, "/")
						llShort = .F.
		
					CASE lcVal == lcAltDelimiter
						lcEndDelimiter = "/>"
						llShort = .T.
				ENDCASE
				lnEndLen = LEN(lcEndDelimiter)
				lnEnd = lnBeg + lnBegLen
				DO WHILE (lnEnd + lnEndLen - 1) <= loString.Length
					lcVal = SYS(2600, loString.BaseAdr-1 + lnEnd, lnEndLen)
					DO CASE
						CASE lcVal = "<" .AND. !(lcVal == lcEndDelimiter)
							DO WHILE lcVal != ">" .AND. lnEnd < loString.Length
								lnEnd = lnEnd + 1
								lcVal = SYS(2600, loString.BaseAdr-1 + lnEnd, 1)
							ENDDO
		
						CASE llShort .AND. lcVal = ">"
							lcEndDelimiter = STUFF(lcBegDelimiter, 2, 0, "/")
							lnEndLen = LEN(lcEndDelimiter)
							llShort  = .F.
		
						CASE lcVal == lcEndDelimiter
							lcRtnSegment = SYS(2600, loString.BaseAdr-1 + lnBeg, lnEnd - lnBeg + lnEndLen)
							IF llReleaseHeap
								this.ReleaseStringFromHeap(loString)
							ENDIF
							RETURN lcRtnSegment
					ENDCASE
					lnEnd = lnEnd + 1
				ENDDO
				lnBeg = loString.Length
			ENDIF
			lnBeg = lnBeg + 1
		ENDDO
		IF llReleaseHeap
			this.ReleaseStringFromHeap(loString)
		ENDIF
		RETURN ""
	ENDPROC

	PROTECTED PROCEDURE Init
		IF this.LoadDLLs
			DECLARE INTEGER HeapAlloc   IN Win32Api AS apiHeapAlloc INTEGER, INTEGER, INTEGER
			DECLARE INTEGER HeapFree    IN Win32APi AS apiHeapFree INTEGER, INTEGER, INTEGER
			DECLARE LONG GetProcessHeap IN Win32API AS apiGetProcessHeap
		ENDIF
		SET EXACT OFF
		this.OnInit()
	ENDPROC

	PROCEDURE oninit		&& User defined Init()
		*-*
		*-*	TODO: Add your code here
		*-*
	ENDPROC

	PROCEDURE releasestringfromheap		&& Releases the fast string from the heap
		LPARAMETERS toString
		apiHeapFree(apiGetProcessHeap(), 0, toString.BaseAdr)
		RETURN .NULL.
	ENDPROC

	PROCEDURE rstring		&& Returns the right part of the string from the starting point
		LPARAMETERS txString, tnBeg
		LOCAL loString, lcRtnString, llReleaseHeap, lnLen
		DO CASE
			CASE PCOUNT() < 2
				RETURN ""
		
			CASE VARTYPE(txString) = 'C'
				llReleaseHeap = .T.
				loString = this.AddStringToHeap(txString)
		
			CASE VARTYPE(txString) = 'O'
				llReleaseHeap = .F.
				loString = txString
		
			OTHERWISE
				RETURN ""
		ENDCASE
		lnLen = loString.Length - tnBeg + 1
		lcRtnString = SYS(2600, loString.BaseAdr-1 + tnBeg, lnLen)
		IF llReleaseHeap
			this.ReleaseStringFromHeap(loString)
		ENDIF
		RETURN lcRtnString
	ENDPROC

	PROCEDURE strextract		&& Fast string replacement for STREXTRACT() function
		LPARAMETERS txString, tcBegDelimiter, tcEndDelimiter, tnOccurrence
		LOCAL lnBeg, lcVal, lnEnd, lnBegLen, lnEndLen, loString, lcRtnString, llReleaseHeap
		DO CASE
			CASE PCOUNT() < 3
				RETURN ""
		
			CASE VARTYPE(txString) = 'C'
				llReleaseHeap = .T.
				loString = this.AddStringToHeap(txString)
		
			CASE VARTYPE(txString) = 'O'
				llReleaseHeap = .F.
				loString = txString
		
			OTHERWISE
				RETURN ""
		ENDCASE
		IF PCOUNT() = 3
			tnOccurrence = 1
		ENDIF
		lnBegLen     = LEN(tcBegDelimiter)
		lnEndLen     = LEN(tcEndDelimiter)
		lnOccurrence = 0
		lnBeg = 1
		DO WHILE (lnBeg + lnBegLen - 1) < loString.Length
			lcVal = SYS(2600, loString.BaseAdr-1 + lnBeg, lnBegLen)
			IF lcVal == tcBegDelimiter
				FOR lnEnd=(lnBeg + lnBegLen) TO (loString.Length - lnEndLen)
					lcVal = SYS(2600, loString.BaseAdr-1 + lnEnd, lnEndLen)
					IF lcVal == tcEndDelimiter
						lnOccurrence = lnOccurrence + 1
						IF lnOccurrence = tnOccurrence
							lcRtnString = SYS(2600, loString.BaseAdr-1 + lnBeg, lnEnd - lnBeg + lnEndLen + 1)
							IF llReleaseHeap
								this.ReleaseStringFromHeap(loString)
							ENDIF
							RETURN lcRtnString
						ENDIF
						lnBeg = lnEnd - 1
						EXIT
					ENDIF
				ENDFOR
			ENDIF
			lnBeg = lnBeg + 1
		ENDDO
		IF llReleaseHeap
			this.ReleaseStringFromHeap(loString)
		ENDIF
		RETURN ""
	ENDPROC

	PROCEDURE substr		&& Fast String replacement for SUBSTR() function
		LPARAMETERS txString, tnBeg, tnLen
		LOCAL loString, lcRtnString, llReleaseHeap
		DO CASE
			CASE PCOUNT() < 2
				RETURN ""
		
			CASE VARTYPE(txString) = 'C'
				llReleaseHeap = .T.
				loString = this.AddStringToHeap(txString)
		
			CASE VARTYPE(txString) = 'O'
				llReleaseHeap = .F.
				loString = txString
		
			OTHERWISE
				RETURN ""
		ENDCASE
		IF PCOUNT() = 2
			tnLen = loString.Length - tnBeg + 1
		ENDIF
		tnLen = MIN(tnLen, loString.Length - tnBeg + 1)
		lcRtnString = SYS(2600, loString.BaseAdr-1 + tnBeg, tnLen)
		IF llReleaseHeap
			this.ReleaseStringFromHeap(loString)
		ENDIF
		RETURN lcRtnString
	ENDPROC

ENDDEFINE
